{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../../App.svelte",
    "../../../RichTextEditor.svelte",
    "../../../PlainTextEditor.svelte",
    "../../../ProsemirrorEditor.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import PlainTextEditor from \"./PlainTextEditor.svelte\"\n  import RichTextEditor from \"./RichTextEditor.svelte\"\n\n</script>\n\n<main>\n\n  <div class=\"header\">\n    <h2>Prosemirror editor</h2> <div class=\"header\"><span>bindings for </span> <img src=\"https://svelte.dev/svelte-logo-horizontal.svg\" alt=\"Svelte logo\"></div>\n  </div>\n\n  <PlainTextEditor/>\n\n  <RichTextEditor/>\n\n</main>\n\n<style>\n\n  div.header {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    justify-content: space-between;\n    flex-wrap: wrap;\n  }\n\n  main {\n    padding: 1em;\n    max-width: 40em;\n    margin: 0 auto;\n  }\n\n  img {\n    height: 2em;\n  }\n\n  div.controls {\n    margin-top: 1em;\n  }\n\n  div.mirror {\n    margin-top: 1em;\n    white-space: pre-line;\n    overflow-wrap: break-spaces;\n  }\n\n  :global(.ui-editor) {\n    box-sizing: border-box;\n    background-color: transparent;\n    color: var(--ui-color-baseline);\n    padding: 1em;\n    border: 1px solid #efefef;\n    border-radius: .5em;\n    display: inline-block;\n    font: inherit;\n    text-rendering: optimizeLegibility;\n    white-space: pre-line;\n    overflow-wrap: break-spaces;\n    vertical-align: top;\n    width: 100%;\n    min-height: 1.25rem;\n    outline: none;\n  }\n</style>\n",
    "<script>\n  import { EditorState } from \"prosemirror-state\";\n  import { schema } from \"prosemirror-schema-basic\";\n  import { exampleSetup } from \"prosemirror-example-setup\";\n\n  import ProsemirrorEditor from \"../../ProsemirrorEditor.svelte\";\n  import { clear, fromJSON, toJSON, getCurrentMarks, getNodeTypeAtSelectionHead } from \"../../helpers\";\n\n  const plugins = exampleSetup({schema, menuBar: false});\n\n  let showEditorState = false;\n  let editor;\n\n  const doc = schema.node(\"doc\", null,\n    [\n      schema.node(\"heading\", {level: 4}, [\n        schema.text(\"I am Rich\", null),\n      ]),\n      schema.node(\"paragraph\", null, [\n        schema.text(\"Hello there! I am Rich, a rich-text editor. Go ahead and edit me as well.\", null),\n      ]),\n      schema.node(\"paragraph\", null, [\n        schema.text(\"I can make text \", null),\n        schema.text(\"bold\", [schema.mark(\"strong\")]),\n        schema.text(\". Or you maybe prefer \", null),\n        schema.text(\"italic\", [schema.mark(\"em\")]),\n        schema.text(\"?\", null)\n      ]),\n      schema.node(\"paragraph\", null, [\n        schema.text(\"You can change the format using the keyboard. E.g. \", null),\n        schema.text(\"Ctrl/Cmd-B\", [schema.mark(\"strong\")]),\n        schema.text(\" will toggle text as bold.\", null),\n      ]),\n    ]\n  );\n\n  const getEditorState = () => EditorState.create({schema, doc, plugins});\n\n  let editorState = getEditorState()\n\n  function handleChange(event) {\n    editorState = event.detail.editorState;\n  }\n\n  const clearEditor = event => {\n    editorState = clear(editorState);\n  }\n\n  const resetEditor = event => {\n    editorState = getEditorState();\n  }\n\n  function handleSave() {\n    try {\n      localStorage.setItem('editor', JSON.stringify(toJSON(editorState)));\n      alert('Saved!')\n    } catch (err) {\n      alert('Error saving your state:' + err.message);\n    }\n  }\n\n  function handleLoad() {\n    const state = localStorage.getItem('editor');\n\n    if (!state) {\n      alert('Nothing saved so far');\n      return\n    }\n\n    try {\n      editorState = fromJSON(JSON.parse(state), schema, plugins);\n    } catch (err) {\n      alert('Error loading your state:' + err.message);\n    }\n  }\n\n  $: currentMarks = editorState ? getCurrentMarks(editorState) : null\n  $: activeMarks = currentMarks ? Object.keys(currentMarks.activeMarks) : []\n  $: nodeAtSelectionHead = editorState ? getNodeTypeAtSelectionHead(editorState) : {}\n\n</script>\n\n<h3>Rich text editor example</h3>\n\n<div class=\"controls\">\n  <button on:click={clearEditor}>Clear</button>\n  <button on:click={resetEditor}>Reset text</button>\n  <button on:click={handleSave}>Save to local storage</button>\n  <button on:click={handleLoad}>Load from local storage</button>\n</div>\n\n<!-- In order to be notified about each selection change, we listen to on:transaction instead of on:change -->\n<ProsemirrorEditor\n  placeholder=\"Go ahead. Type and format\"\n  {editorState}\n  on:transaction={handleChange}\n/>\n\n<div class=\"controls\">\n\n  Additional information about the current editor instance:\n\n  <ul>\n\n    <!-- Show which marks are currently active, e.g. to highlight a menu button -->\n    <li><b>Active marks: </b>{activeMarks && activeMarks.length ? activeMarks.toString() : 'none'}</li>\n\n    <!-- Show which node is currently active at the selection head, e.g. to highlight a menu button menu -->\n    <li>\n      <b>Type of node at selection head:</b>\n        {nodeAtSelectionHead.type.name}\n        {nodeAtSelectionHead.attrs && nodeAtSelectionHead.attrs.level ? nodeAtSelectionHead.attrs.level: ''}\n    </li>\n\n  </ul>\n\n  <p>\n    <label>Show serialized editor state\n      <input type=\"checkbox\" bind:checked={showEditorState}/>\n    </label>\n  </p>\n</div>\n\n{#if showEditorState}\n  <pre>{JSON.stringify(toJSON(editorState), null, 2)}</pre>\n{/if}\n\n<style>\n  div.controls {\n    margin: .5em .5em;\n  }\n\n  ul {\n    margin-top: .5em;\n  }\n\n  label {\n    margin-top: .5em;\n  }\n\n  pre {\n    max-height: 20em;\n    overflow-y: auto;\n    overflow-x: hidden;\n    border-bottom: 2px solid orangered;\n    border-top: 2px solid orangered;\n  }\n</style>\n",
    "<script>\n  import ProsemirrorEditor from '../../ProsemirrorEditor.svelte';\n  import { createMultiLineEditor, getPlainText, clear, selectAll } from \"../../helpers\";\n\n  const getEditorState = () => createMultiLineEditor('Go ahead. Edit me!');\n\n  let editor;\n  let editorState = getEditorState();\n\n  $: textContent = editorState ? getPlainText(editorState) : ''\n\n  const handleChange = event => {\n    editorState = event.detail.editorState;\n  }\n\n  const focusEditor = () => {\n    editor && editor.focus();\n  }\n\n  const clearEditor = event => {\n    editorState = clear(editorState);\n    focusEditor();\n  }\n\n  const resetEditor = event => {\n    editorState = getEditorState();\n    focusEditor();\n  }\n\n  const selectAllText = event => {\n    editorState = selectAll(editorState);\n    focusEditor();\n  }\n\n</script>\n\n<h3>Plain text editor example</h3>\n\n<div class=\"controls\">\n  <button on:click={clearEditor}>Clear</button>\n  <button on:click={resetEditor}>Reset text</button>\n  <button on:click={selectAllText}>Select all</button>\n  <button on:click={focusEditor}>Focus</button>\n</div>\n\n<ProsemirrorEditor\n  placeholder=\"Text goes here\"\n  {editorState}\n  bind:editor={editor}\n  on:change={handleChange}\n  debounceChangeEventsInterval={0}/>\n\n<div class=\"mirror\">Current plain text content of the editor: \"{textContent}\"</div>\n\n<style>\n\n  main {\n    padding: 1em;\n    max-width: 40em;\n    margin: 0 auto;\n  }\n\n  img {\n    height: 2em;\n  }\n\n  div.controls {\n    margin: .5em .5em;\n  }\n\n  div.mirror {\n    margin-top: 1em;\n    white-space: pre-line;\n    overflow-wrap: break-spaces;\n  }\n\n  :global(.ui-editor) {\n    box-sizing: border-box;\n    background-color: transparent;\n    padding: 1em;\n    border: 1px solid #efefef;\n    border-radius: .5em;\n    display: inline-block;\n    font: inherit;\n    text-rendering: optimizeLegibility;\n    white-space: pre-line;\n    overflow-wrap: break-spaces;\n    vertical-align: top;\n    width: 100%;\n    min-height: 1.25rem;\n    outline: none;\n  }\n</style>\n",
    "<script>\n  import { onMount, onDestroy, createEventDispatcher } from 'svelte'\n  import { createSingleLineEditor } from './helpers/state'\n  import { EditorView } from \"prosemirror-view\"\n  import { EditorState } from \"prosemirror-state\"\n\n  const dispatch = createEventDispatcher()\n\n  /** @type string */\n  export let className = \"ui-editor\"\n\n  /** @type EditorState */\n  export let editorState = createSingleLineEditor()\n\n  /** @type string */\n  export let placeholder = ''\n\n  /** Reference to the editor view\n   *  @type EditorView|null */\n  export let view = null\n\n  /** Debounce change events (set to zero for immediate updates) */\n  export let debounceChangeEventsInterval = 50\n\n  /** Reference to the editor component\n   *  @type HTMLDivElement */\n  export let editor = null\n\n  /** Focus the content-editable div */\n  export function focus() {\n    editor && editor.focus()\n  }\n\n  /** Blur the content-editable div */\n  export function blur() {\n    editor && editor.blur()\n  }\n\n  /** Tracks the timeout id of the last time the change event was dispatched */\n  let dispatchLastEditTimeout\n\n  /** Tracks whether changes to editor state were not yet dispatched */\n  let isDirty = false\n\n  $: if (view && editorState && !isDirty) {\n    view.updateState(editorState) // necessary to keep the DOM in sync with the editor state on external updates\n  }\n\n  /** Tracks whether the editor is empty (i.e. has a content size of 0) */\n  let editorIsEmpty\n  $: editorIsEmpty = editorState ? editorState.doc.content.size === 0\n    || (editorState.doc.textContent === \"\" && editorState.doc.content.size < 3) : true\n\n  /** Dispatches a change event and resets whether the editor state is dirty */\n  const dispatchChangeEvent = () => {\n    if (isDirty) {\n      dispatch('change', {editorState})\n      isDirty = false\n    }\n  }\n\n  /**\n   * Captures custom events from plugins and dispatches them with a new event type (based on event.detail.type)\n   * @param event {CustomEvent}\n   */\n  const onCustomEvent = event => {\n    if (event.detail) {\n      const {type, ...detail} = event.detail\n      dispatch(type || 'custom', detail)\n    }\n  }\n\n  onMount(() => {\n    view = new EditorView({mount: editor}, {\n      state: editorState,\n      dispatchTransaction: (transaction) => {\n        editorState = view.state.apply(transaction)\n\n        const contentHasChanged = !editorState.doc.eq(view.state.doc)\n\n        if (contentHasChanged) {\n          isDirty = true\n          if (debounceChangeEventsInterval > 0) {\n            if (dispatchLastEditTimeout) clearTimeout(dispatchLastEditTimeout)\n            dispatchLastEditTimeout = setTimeout(dispatchChangeEvent, 50)\n          } else {\n            setTimeout(dispatchChangeEvent, 0)\n          }\n        }\n\n        view.updateState(editorState)\n\n        dispatch('transaction', {view, editorState, isDirty, contentHasChanged})\n      },\n    })\n  })\n\n  onDestroy(() => {\n    view.destroy()\n  })\n\n</script>\n\n<div class={className}\n     class:ProseMirror={true}\n     class:editor_empty={editorIsEmpty}\n     data-placeholder={placeholder}\n     bind:this={editor}\n     on:focus\n     on:blur\n     on:keydown\n     on:custom={onCustomEvent}\n></div>\n\n<style>\n\n  :global(body) {\n    --ui-color-placeholder: #AAAAAA;\n  }\n\n  :global(.ProseMirror) {\n    position: relative;\n  }\n\n  :global(.ProseMirror) {\n    word-wrap: break-word;\n    white-space: pre-wrap;\n    -webkit-font-variant-ligatures: none;\n    font-variant-ligatures: none;\n  }\n\n  :global(.ProseMirror) pre {\n    white-space: pre-wrap;\n  }\n\n  :global(.ProseMirror) li {\n    position: relative;\n  }\n\n  :global(.ProseMirror-hideselection *::selection) {\n    background: transparent;\n  }\n\n  :global(.ProseMirror-hideselection *::-moz-selection) {\n    background: transparent;\n  }\n\n  :global(.ProseMirror-hideselection) {\n    caret-color: transparent;\n  }\n\n  :global(.ProseMirror-selectednode) {\n    outline: 2px solid #8cf;\n  }\n\n  /* Make sure li selections wrap around markers */\n\n  :global(li.ProseMirror-selectednode) {\n    outline: none;\n  }\n\n  :global(li.ProseMirror-selectednode:after) {\n    content: \"\";\n    position: absolute;\n    left: -32px;\n    right: -2px;\n    top: -2px;\n    bottom: -2px;\n    border: 2px solid #8cf;\n    pointer-events: none;\n  }\n\n  :global(.ProseMirror .empty-node::before) {\n    position: absolute;\n    color: #aaa;\n    cursor: text;\n  }\n\n  :global(.ProseMirror .empty-node:hover::before) {\n    color: #777;\n  }\n\n  :global(.ProseMirror.editor_empty::before) {\n    position: absolute;\n    content: attr(data-placeholder);\n    pointer-events: none;\n    color: var(--ui-color-placeholder);\n  }\n\n</style>\n"
  ],
  "names": [],
  "mappings": "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"
}